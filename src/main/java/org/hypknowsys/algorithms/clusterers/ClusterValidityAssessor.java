/*
 * Copyright (C) 2000-2005, Henner Graubitz, Myra Spiliopoulou, Karsten 
 * Winkler. All rights reserved.
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

package org.hypknowsys.algorithms.clusterers;

import java.io.Serializable;
import java.text.NumberFormat;
import java.util.Locale;
import org.hypknowsys.algorithms.core.Instances;
import org.hypknowsys.algorithms.core.InstancesMetadata;
import org.hypknowsys.misc.io.TextFile;
import org.hypknowsys.server.Algorithm;
import org.hypknowsys.server.Server;
import org.hypknowsys.server.TaskProgress;

/**
 * Based on weka.clusterers.Clusterer, Revision 1.8:
 * Copyright (C) 1999 Mark Hall (mhall@cs.waikato.ac.nz)<p>
 *
 * Abstract class for various algorithms evaluating the clusering validity of
 * clustering generated by instances of Clusterer. 
 * According to the chosen distance measure, STRING and DATE attributes might be
 * ignored for computing the distance between two instances. Check the 
 * documentation of the respective distance measure.
 *
 * @version 0.1, 28 June 2004
 * @author Karsten Winkler, kwinkler{at}hypKNOWsys{d0t}org
 */

public abstract class ClusterValidityAssessor 
implements Serializable, Algorithm {
  
  /* ########## ########## ########## ########## ########## ######### */
  /* ########## attributes  */
  /* ########## ########## ########## ########## ########## ######### */
  
  /**
   * Clusterer associated with this clustering validity evaluator
   */
  protected Clusterer MyClusterer = null;
  
  /**
   * Should internal cluster quality be evaluated? Can assume one of the
   * following values: Clusterer.ASSESS_CLUSTER_VALIDITY:_FULL,
   * Clusterer.ASSESS_CLUSTER_VALIDITY:_TRUE,
   * Clusterer.ASSESS_CLUSTER_VALIDITY:_QUICK, or
   * Clusterer.ASSESS_CLUSTER_VALIDITY:_FALSE,
   */
  protected int EvaluateInternalQuality = DEFAULT_ASSESS_CLUSTER_VALIDITY;
  
 /**
   * Array containing cluster cardinalities: The array size equals
   * this.NumberOfClusters and ClusterCardinality[0] represents the
   * cardinality of the first cluster (ID = 0). Analogously, the 
   * cardinality of the last cluster is stored in 
   * ClusterCardinality[MyClusterer.numberOfClusters() - 1].
   */
  protected int[] ClusterCardinality = null;
  
 /**
   * Array containing relative cluster cardinalities: The array size equals
   * this.NumberOfClusters and RelativeClusterCardinality[0] represents the
   * relative cardinality of the first cluster (ID = 0). Analogously, the 
   * relative cardinality of the last cluster is stored in 
   * RelativeClusterCardinality[MyClusterer.numberOfClusters() - 1].
   */
  protected double[] RelativeClusterCardinality = null;
  
  /**
   * Holds the number of empty clusters.
   */
  protected int NumberOfEmptyClusters = 0;
  
  /**
   * Holds the number of non-empty clusters.
   */
  protected int NumberOfNonEmptyClusters = 0;
  
  /**
   * Holds the sum of all cluster cardinalities.
   */
  protected long SumClusterCardinality = 0;
  
  /**
   * Array that holds the training instances associated to each cluster,
   * whereas the data is stored analogously to the array ClusterCardinality.
   */
  protected Instances[] TrainingInstancesPerCluster = null;
  
  /**
   * Array that holds the metadata for the training instances associated to 
   * each cluster, whereas the data is stored analogously to the array 
   * ClusterCardinality.
   */
  protected InstancesMetadata[] TrainingInstancesMetadataPerCluster = null;
  
  /**
   * Array containing the sum of intra-cluster distances for each cluster, 
   * whereas the data is stored analogously to the array ClusterCardinality.
   * Intra-cluster distance is defined as the distance between two instances 
   * that are assigned to the same cluster.
   */
  protected double[] SumIntraClusterDistances = null;
  
  /**
   * Holds the number of all intra-cluster distances for each cluster, 
   * whereas the data is stored analogously to the array ClusterCardinality.
   * Intra-cluster distance is defined as the distance between two instances 
   * that are assigned to the same cluster.
   */
  protected long[] NumberOfIntraClusterDistances = null;
  
  /**
   * Array containing the sum of of squared intra-cluster distances for each 
   * cluster, whereas the data is stored analogously to the array 
   * ClusterCardinality. Intra-cluster distance is defined as the distance 
   * between two instances that are assigned to the same cluster.
   */
  protected double[] SumOfSquaredIntraClusterDistances = null;
  
  /**
   * Array containing the mean of intra-cluster distance for each cluster, 
   * whereas the data is stored analogously to the array ClusterCardinality.
   * Intra-cluster distance is defined as the distance between two instances 
   * that are assigned to the same cluster.
   */
  protected double[] MeanIntraClusterDistances = null;
  
  /**
   * Array containing the standard deviation of intra-cluster distance for 
   * each cluster, whereas the data is stored analogously to the array 
   * ClusterCardinality. Intra-cluster distance is defined as the distance 
   * between two instances that are assigned to the same cluster.
   */
  protected double[] StdDevIntraClusterDistances = null;
  
  /**
   * Holds the sum of intra-cluster distances for all clusters, 
   * whereas the data is stored analogously to the array ClusterCardinality.
   * Intra-cluster distance is defined as the distance between two instances 
   * that are assigned to the same cluster.
   */
  protected double SumIntraClusterDistance = 0.0d;
  
  /**
   * Holds the number of all intra-cluster distances for all clusters, 
   * whereas the data is stored analogously to the array ClusterCardinality.
   * Intra-cluster distance is defined as the distance between two instances 
   * that are assigned to the same cluster.
   */
  protected long NumberOfIntraClusterDistance = 0;
  
  /**
   * Holds the sum of of squared intra-cluster distances for all 
   * clusters, whereas the data is stored analogously to the array 
   * ClusterCardinality. Intra-cluster distance is defined as the distance 
   * between two instances that are assigned to the same cluster.
   */
  protected double SumOfSquaredIntraClusterDistance = 0.0d;
  
  /**
   * Holds the mean of intra-cluster distance for all clusters, 
   * whereas the data is stored analogously to the array ClusterCardinality.
   * Intra-cluster distance is defined as the distance between two instances 
   * that are assigned to the same cluster.
   */
  protected double MeanIntraClusterDistance = 0.0d;
  
  /**
   * Holds the standard deviation of intra-cluster distance for 
   * all clusters, whereas the data is stored analogously to the array 
   * ClusterCardinality. Intra-cluster distance is defined as the distance 
   * between two instances that are assigned to the same cluster.
   */
  protected double StdDevIntraClusterDistance = 0.0;
  
  /**
   * Array containing the sum of intra-centroid distances for each cluster, 
   * whereas the data is stored analogously to the array ClusterCardinality.
   * Intra-centroid distance is defined as the distance between an instance 
   * and its assigned cluster centroid.
   */
  protected double[] SumIntraCentroidDistances = null;
  
  /**
   * Array containing the sum of of squared intra-centroid distances for each 
   * cluster, whereas the data is stored analogously to the array 
   * ClusterCardinality. Intra-centroid distance is defined as the distance 
   * between an instance and its assigned cluster centroid.
   */
  protected double[] SumOfSquaredIntraCentroidDistances = null;
  
  /**
   * Array containing the mean of intra-centroid distance for each cluster, 
   * whereas the data is stored analogously to the array ClusterCardinality.
   * Intra-centroid distance is defined as the distance between an instance 
   * and its assigned cluster centroid.
   */
  protected double[] MeanIntraCentroidDistances = null;
  
  /**
   * Array containing the standard deviation of intra-centroid distance for 
   * each cluster, whereas the data is stored analogously to the array 
   * ClusterCardinality. Intra-centroid distance is defined as the distance 
   * between an instance and its assigned cluster centroid.
   */
  protected double[] StdDevIntraCentroidDistances = null;
  
  /**
   * Holds the sum of intra-centroid distances for all clusters, 
   * whereas the data is stored analogously to the array ClusterCardinality.
   * Intra-centroid distance is defined as the distance between an instance 
   * and its assigned cluster centroid.
   */
  protected double SumIntraCentroidDistance = 0.0d;
  
  /**
   * Holds the sum of of squared intra-centroid distances for all 
   * clusters, whereas the data is stored analogously to the array 
   * ClusterCardinality. Intra-centroid distance is defined as the distance 
   * between an instance and its assigned cluster centroid.
   */
  protected double SumOfSquaredIntraCentroidDistance = 0.0d;
  
  /**
   * Holds the mean of intra-centroid distance for all clusters, 
   * whereas the data is stored analogously to the array ClusterCardinality.
   * Intra-centroid distance is defined as the distance between an instance 
   * and its assigned cluster centroid.
   */
  protected double MeanIntraCentroidDistance = 0.0d;
  
  /**
   * Holds the standard deviation of intra-centroid distance for 
   * all clusters, whereas the data is stored analogously to the array 
   * ClusterCardinality. Intra-centroid distance is defined as the distance 
   * between an instance and its assigned cluster centroid.
   */
  protected double StdDevIntraCentroidDistance = 0.0d;
  
  /**
   * Holds the sum of all inter-cluster distances. Inter-cluster distance is
   * defined as the distance between two instances that are assigned to 
   * different clusters.
   */
  protected double SumInterClusterDistance = 0.0d;
  
  /**
   * Holds the number of all inter-cluster distances. Inter-cluster distance is
   * defined as the distance between two instances that are assigned to 
   * different clusters.
   */
  protected long NumberOfInterClusterDistances = 0;
  
  /**
   * Holds the sum of all squared inter-cluster distances. Inter-cluster 
   * distance is defined as the distance between two instances that are 
   * assigned to different clusters.
   */
  protected double SumOfSquaredInterClusterDistance = 0.0d;
  
  /**
   * Holds the mean of inter-cluster distances. Inter-cluster distance is
   * defined as the distance between two instances that are assigned to 
   * different clusters.
   */
  protected double MeanInterClusterDistance = 0.0d;
  
  /**
   * Holds the standard deviation of inter-cluster distances. Inter-cluster 
   * distance is defined as the distance between two instances that are 
   * assigned to different clusters.
   */
  protected double StdDevInterClusterDistance = 0.0d;
  
  /**
   * Holds the sum of all inter-centroid distances. Inter-centroid distance is
   * defined as the distance between two different cluster centroids.
   */
  protected double SumInterCentroidDistance = 0.0d;
  
  /**
   * Holds the number of all inter-centroid distances. Inter-centroid distance 
   * is defined as the distance between two different cluster centroids.
   */
  protected long NumberOfInterCentroidDistances = 0;
  
  /**
   * Holds the sum of all squared inter-centroid distances. Inter-centroid 
   * distance is defined as the distance between two different cluster 
   * centroids.
   */
  protected double SumOfSquaredInterCentroidDistance = 0.0d;
  
  /**
   * Holds the mean of inter-centroid distances. Inter-centroid distance is
   * defined as the distance between two different cluster centroids.
   */
  protected double MeanInterCentroidDistance = 0.0d;
  
  /**
   * Holds the standard deviation of inter-centroid distances. Inter-centroid 
   * distance is defined as the distance between two different cluster 
   * centroids.
   */
  protected double StdDevInterCentroidDistance = 0.0d;
  
 /**
   * Array containing cluster digests that are short strings characterizing 
   * clusters: The array size equals this.NumberOfClusters and 
   * ClusterCardinality[0] is the digest of the first cluster (ID = 0). 
   * Analogously, the digest of the last cluster is stored in 
   * ClusterCardinality[umberOfClusters - 1].
   */
  protected String[] ClusterDigests = null;
  
  /**
   * Number formatter for outputting doubles
   */
  private NumberFormat MyNumberFormat = NumberFormat.getInstance(Locale.US);
    
  /* ########## ########## ########## ########## ########## ######### */
  /* ########## auxiliary attributes  */
  /* ########## ########## ########## ########## ########## ######### */
  
  /**
   * Temporary variable holding cluster assignments while iterating
   */
  protected transient int[] ClusterAssignments = null;
  
  /**
   * hypKNOWsys server that observes the progress of this algorithm
   */
  protected transient Server MyServer = null;
  
  /**
   * hypKNOWsys task progress instance for communicating the progress of 
   * this algorithm
   */
  protected transient TaskProgress MyTaskProgress = null;
  
  /**
   * Thread that is associated with this algorithm
   */
  protected transient Thread MyTaskThread = null;
  
  /**
   * ARFF file of cluster validity indices to be created/extended or null, 
   * if file creation should be skipped
   */
  protected transient TextFile ClusterValidityIndicesArffFile = null;
  
  /**
   * Temporary string buffer for performance purposes only
   */
  private transient StringBuffer TmpStringBuffer = null;
  
  /* ########## ########## ########## ########## ########## ######### */
  /* ########## constants  */
  /* ########## ########## ########## ########## ########## ######### */
  
  /**
   * Default setting of attribute this.VerboseMode
   */
  protected static final boolean DEFAULT_VERBOSE_MODE = false;

  /**
   * One allowed setting of this.EvaluateInternalQuality
   */
  protected static final int ASSESS_CLUSTER_VALIDITY_FULL = 4;
  
  /**
   * One allowed setting of this.EvaluateInternalQuality
   */
  protected static final int ASSESS_CLUSTER_VALIDITY_TRUE = 1;
  
  /**
   * One allowed setting of this.EvaluateInternalQuality
   */
  protected static final int ASSESS_CLUSTER_VALIDITY_QUICK = 2;
  
  /**
   * One allowed setting of this.EvaluateInternalQuality
   */
  protected static final int ASSESS_CLUSTER_VALIDITY_FALSE = 3;
  
  /**
   * Default setting of attribute this.EvaluateInternalQuality
   */
  protected static final int DEFAULT_ASSESS_CLUSTER_VALIDITY = 
  ASSESS_CLUSTER_VALIDITY_FALSE;

  /* ########## ########## ########## ########## ########## ######### */
  /* ########## constructors  */
  /* ########## ########## ########## ########## ########## ######### */
  
  /* ########## ########## ########## ########## ########## ######### */
  /* ########## accessor methods */
  /* ########## ########## ########## ########## ########## ######### */
  
  /* ########## ########## ########## ########## ########## ######### */
  
  /**
   * Returns the mean of intra-centroid distance for all clusters, 
   * Intra-centroid distance is defined as the distance between an instance 
   * and its assigned cluster centroid.
   * @return the mean of intra-centroid distance for all clusters
   */
  
  public double getMeanIntraCentroidDistance() {
    
    return MeanIntraCentroidDistance;
    
  }
  
  /* ########## ########## ########## ########## ########## ######### */
  
  /**
   * Returns the mean of inter-centroid distances. Inter-centroid distance is
   * defined as the distance between two different cluster centroids.
   * @return the mean of inter-centroid distances
   */
  
  public double getMeanInterCentroidDistance() {
    
    return MeanInterCentroidDistance;
    
  }
  
  /* ########## ########## ########## ########## ########## ######### */
  /* ########## mutator methods */
  /* ########## ########## ########## ########## ########## ######### */
  
  /* ########## ########## ########## ########## ########## ######### */
  /* ########## standard methods */
  /* ########## ########## ########## ########## ########## ######### */
  
  /**
   * Returns a string describing this clusterer.
   *
   * @return a description of the clusterer as a string
   */
  
  public String toString() {
    
    TmpStringBuffer = new StringBuffer(1000);
    
    TmpStringBuffer.append("\n\n" + this.getClass().toString() + "\n\n");
    TmpStringBuffer.append("DistanceMeasure: ");
    TmpStringBuffer.append(MyClusterer.MyDistanceMeasure.getOptionArguments() 
    + "\n");
    
    return TmpStringBuffer.toString();
    
  }
  
  /* ########## ########## ########## ########## ########## ######### */
  /* ########## interface Algorithm methods */
  /* ########## ########## ########## ########## ########## ######### */
  
  /**
   * Sets the hypKNOWsys server, which listens to the progress of this
   * algorithm, and provides am implementation of TaskProgress as well as
   * the associated thread.
   *
   * @param pServer the hypKNOWsys server of the associated task
   * @param pTaskProgress the current progress of the associated task
   * @param pMyTaskThread tread associated with the task
   */
  
  public void setTaskProgressListener(Server pServer, 
  TaskProgress pTaskProgress, Thread pMyTaskThread) {
    
    MyServer = pServer;
    MyTaskProgress = pTaskProgress;
    MyTaskThread = pMyTaskThread;
    
  }
  
  /* ########## ########## ########## ########## ########## ######### */
  /* ########## public methods */
  /* ########## ########## ########## ########## ########## ######### */
  
  /**
   * The cluster validity of the created clustering is assessed.
   *
   * @param pEvaluateInternalQuality an integer that represents the level of
   * detail of cluster validity assessment
   * @param pMyClusterer the clusterer that this ClusterValidityAssessor is 
   * associated with 
   */
  
  public void assessClusterValidity(int pEvaluateInternalQuality,
  Clusterer pMyClusterer) {
  
    EvaluateInternalQuality = pEvaluateInternalQuality;
    MyClusterer = pMyClusterer;
    
    if (MyClusterer.TrainingInstances.checkForStringAttributes()) {
      System.err.println("Warning: Can't handle string attributes! "
      + "All string attributes will be ignored.");
    }
    
    if (EvaluateInternalQuality != ASSESS_CLUSTER_VALIDITY_FALSE) {
      ClusterAssignments = new int[MyClusterer.TrainingInstances
      .numInstances()];
      this.evaluateClusterValidity();
    }
    
  }
  
  /* ########## ########## ########## ########## ########## ######### */
  /* ########## protected methods */
  /* ########## ########## ########## ########## ########## ######### */
  
  /**
   * Evaluates cluster validity by computing cluster cardinalities, 
   * intra-cluster distances and squared intra-cluster distances.
   * Prerequisites: The specific k-means algorithm must have been executed
   * and the array ClusterCentroids contains the final cluster centroids.
   */
  
  protected abstract void evaluateClusterValidity();
        
  /* ########## ########## ########## ########## ########## ######### */
  
  /**
   * Appends the section containing cluster validity indices and details about 
   * all cluster centroids to existing and open HTML report. The text file 
   * remains open.
   */
  
  protected abstract void createHtmlReportClusterValiditySection();
  
  /* ########## ########## ########## ########## ########## ######### */
  
  /**
   * Notifies MyServer about the specified progress of this algorithm,
   * if MyServer != null and MyTaskProgress != null and MyTaskThread != null.
   * The progress value pValue is either in the interval [0; 100] or equals 
   * org.hypknowsys.server.TaskProgress.INDETERMINATE.
   *
   * @param pValue the current progress of this algorithm
   * @param pNote the note describing the current state of this algorithm
   */
  
  protected void updateTaskProgress(int pValue, String pNote) {
    
    if (MyServer != null && MyTaskProgress != null && MyTaskThread != null) {
      MyTaskProgress.update(pValue, pNote);
      MyServer.setTaskProgress(MyTaskProgress, MyTaskThread);
    }
    
  }
  
  /* ########## ########## ########## ########## ########## ######### */
  
  /**
   * Notifies MyServer about the specified progress of this algorithm,
   * if MyServer != null and MyTaskProgress != null and MyTaskThread != null.
   * The progress value pValue is either in the interval [0; 100] or equals 
   * org.hypknowsys.server.TaskProgress.INDETERMINATE.
   *
   * @param pValue the current progress of this algorithm
   * @param pNewMaxValue the new maximum progress value of this task
   * @param pNote the note describing the current state of this algorithm
   */
  
  protected void updateTaskProgress(int pValue, int pNewMaxValue, 
  String pNote) {
    
    if (MyServer != null && MyTaskProgress != null && MyTaskThread != null) {
      MyTaskProgress.update(pValue, pNewMaxValue, pNote);
      MyServer.setTaskProgress(MyTaskProgress, MyTaskThread);
    }
    
  }
  
  /* ########## ########## ########## ########## ########## ######### */
  
  /**
   * Outputs a log entry to System.out and/or the HTML log file according to
   * the settings of MyClusterer.VerboseMode and MyClusterer.HtmlReportFileName.
   *
   * @param pIsHtmlOutput if true, the log entry will be output to the HTML
   * report as well
   * @param pLogEntry the log entry to be output
   */
  
  protected void outputLogEntry(boolean pIsHtmlOutput, String pLogEntry) {
    
    if (MyClusterer != null) {
      if (MyClusterer.VerboseMode) {
        System.out.println(pLogEntry);
      }
      if (pIsHtmlOutput && MyClusterer.HtmlReportFileName != null) {
        MyClusterer.appendHtmlReportLogEntry(pLogEntry);
      }
    }
    
  }
  
  /* ########## ########## ########## ########## ########## ######### */

  /**
   * Initializes all attributes that are required to assess the cluster 
   * validity.
   */
  
  protected void init() {
        
    ClusterCardinality = new int [MyClusterer.numberOfClusters()];
    RelativeClusterCardinality = new double[MyClusterer.numberOfClusters()];
    ClusterDigests = new String[MyClusterer.numberOfClusters()];
    for (int i = 0; i < MyClusterer.numberOfClusters(); i++) {
      ClusterDigests[i] = "Cluster: " + i;
    }
    
    TrainingInstancesPerCluster = new Instances[MyClusterer
    .numberOfClusters()];
    TrainingInstancesMetadataPerCluster = new InstancesMetadata[MyClusterer
    .numberOfClusters()];
    SumIntraClusterDistances = new double[MyClusterer
    .numberOfClusters()];
    NumberOfIntraClusterDistances = new long[MyClusterer
    .numberOfClusters()];
    SumOfSquaredIntraClusterDistances = new double[MyClusterer
    .numberOfClusters()];
    MeanIntraClusterDistances = new double[MyClusterer
    .numberOfClusters()];
    StdDevIntraClusterDistances = new double[MyClusterer
    .numberOfClusters()];
    
    SumIntraCentroidDistances = new double[MyClusterer
    .numberOfClusters()];
    SumOfSquaredIntraCentroidDistances = new double[MyClusterer
    .numberOfClusters()];
    MeanIntraCentroidDistances = new double[MyClusterer
    .numberOfClusters()];
    StdDevIntraCentroidDistances = new double[MyClusterer
    .numberOfClusters()];
    
    for (int i = 0; i < MyClusterer.numberOfClusters(); i++) {
      ClusterCardinality[i] = 0;
      RelativeClusterCardinality[i] = 0.0d;
      TrainingInstancesPerCluster[i] = new Instances(MyClusterer
      .TrainingInstances, 0);
      SumIntraClusterDistances[i] = 0.0d;
      NumberOfIntraClusterDistances[i] = 0L;
      SumOfSquaredIntraClusterDistances[i] = 0.0d;
      MeanIntraClusterDistances[i] = 0.0d;
      StdDevIntraClusterDistances[i] = 0.0d;
      SumIntraCentroidDistances[i] = 0.0d;
      SumOfSquaredIntraCentroidDistances[i] = 0.0d;
      MeanIntraCentroidDistances[i] = 0.0d;
      StdDevIntraCentroidDistances[i] = 0.0d;
    }
    
    NumberOfEmptyClusters = 0;
    NumberOfNonEmptyClusters = 0;
    
    SumInterClusterDistance = 0.0d;
    NumberOfInterClusterDistances = 0L;
    SumOfSquaredInterClusterDistance = 0.0d;
    MeanInterClusterDistance = 0.0d;
    StdDevInterClusterDistance = 0.0d;
    
    SumInterCentroidDistance = 0.0d;
    NumberOfInterCentroidDistances = 0L;
    SumOfSquaredInterCentroidDistance = 0.0d;
    MeanInterCentroidDistance = 0.0d;
    StdDevInterCentroidDistance = 0.0d;
    
    SumIntraClusterDistance = 0.0d;
    NumberOfIntraClusterDistance = 0L;
    SumOfSquaredIntraClusterDistance = 0.0d;
    MeanIntraClusterDistance = 0.0d;
    StdDevIntraClusterDistance = 0.0d;
    
    SumIntraCentroidDistance = 0.0d;
    SumClusterCardinality = 0;
    SumOfSquaredIntraCentroidDistance = 0.0d;
    MeanIntraCentroidDistance = 0.0d;
    StdDevIntraCentroidDistance = 0.0d;
    
 }
    
  /* ########## ########## ########## ########## ########## ######### */
  
  /**
   * Formats double number for output.
   * @param pDouble the double number to be formatted
   * @return pDouble as a formatted string
   */
  
  protected String formatDouble(double pDouble) {
    
    return this.formatDouble(pDouble, 3, false);
    
  }
    
  /**
   * Formats double number for output.
   * @param pDouble the double number to be formatted
   * @param pAfterDecimalPoint the number of enforced digits after the 
   * decimal point
   * @param pAllowInfinity if false; N/A is output when pDouble is not
   * a number or infinite
   * @return pDouble as a formatted string
   */
  
  protected String formatDouble(double pDouble, int pAfterDecimalPoint,
  boolean pAllowInfinity) {
    
    MyNumberFormat.setMaximumFractionDigits(pAfterDecimalPoint);
    MyNumberFormat.setMinimumFractionDigits(pAfterDecimalPoint);
    if ((Double.isInfinite(pDouble) && !pAllowInfinity) 
    || Double.isNaN(pDouble)) {
      return "N/A";
    }
    else if (Double.isInfinite(pDouble)) {
      return "Infinity";
    }
    else {
      return MyNumberFormat.format(pDouble);
    }
    
  }
    
  /* ########## ########## ########## ########## ########## ######### */
  /* ########## private methods */
  /* ########## ########## ########## ########## ########## ######### */
  
  /* ########## ########## ########## ########## ########## ######### */
  /* ########## static methods */
  /* ########## ########## ########## ########## ########## ######### */
  
  /* ########## ########## ########## ########## ########## ######### */
  /* ########## main method for debugging purposes  */
  /* ########## ########## ########## ########## ########## ######### */
  
}